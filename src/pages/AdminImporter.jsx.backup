
import React, { useState, useEffect } from 'react';
import { db } from '@/api/supabaseClient';
import { supabaseAdmin } from '@/api/supabaseClient';
import GoogleMap from '@/components/GoogleMap';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Loader2, Search, Plus, Check, MapPin, Star, Image as ImageIcon } from 'lucide-react';
import { useToast } from "@/components/ui/use-toast";
import { useQuery } from "@tanstack/react-query";

export default function AdminImporter() {
    const [query, setQuery] = useState('');
    const [results, setResults] = useState([]);
    const [loading, setLoading] = useState(false);
    const [importing, setImporting] = useState({});
    const { toast } = useToast();
    const [mapReady, setMapReady] = useState(false);
    const [pagination, setPagination] = useState(null);
    const [selectedPlaces, setSelectedPlaces] = useState({});

    // Automated import state
    const [autoImporting, setAutoImporting] = useState(false);
    const [autoProgress, setAutoProgress] = useState({ current: 0, total: 0, category: '' });
    const [autoStats, setAutoStats] = useState({ imported: 0, skipped: 0, errors: 0 });

    // Predefined search categories for Koh Samui
    const searchCategories = [
        'restaurant', 'thai restaurant', 'seafood restaurant', 'italian restaurant',
        'beach restaurant', 'cafe', 'coffee shop', 'bar', 'beach bar', 'nightclub',
        'hotel', 'resort', 'beach resort', 'boutique hotel', 'villa', 'hostel',
        'spa', 'massage', 'thai massage', 'wellness center', 'yoga studio',
        'diving center', 'snorkeling', 'boat tour', 'water sports',
        'temple', 'waterfall', 'viewpoint', 'beach',
        'supermarket', 'convenience store', 'pharmacy', 'hospital',
        'car rental', 'motorbike rental', 'travel agency',
        'market', 'night market', 'shopping mall', 'souvenir shop'
    ];

    const { data: user } = useQuery({
        queryKey: ["currentUser"],
        queryFn: () => db.auth.me(),
    });

    // Create admin db helper that uses service role key
    const adminDb = {
        entities: {
            ServiceProvider: {
                create: async (data) => {
                    const { data: result, error } = await supabaseAdmin
                        .from('service_providers')
                        .insert(data)
                        .select()
                        .single();
                    if (error) throw error;
                    return result;
                }
            }
        }
    };

    useEffect(() => {
        // Check if map script is loaded
        const interval = setInterval(() => {
            if (window.google && window.google.maps && window.google.maps.places) {
                setMapReady(true);
                clearInterval(interval);
            }
        }, 500);
        return () => clearInterval(interval);
    }, []);

    const searchPlaces = async (nextPage = false) => {
        if (!nextPage && !query.trim()) return;
        if (!mapReady) {
            toast({
                title: "המפה טרם נטענה",
                description: "אנא המתן מספר שניות ונסה שוב",
                variant: "destructive"
            });
            return;
        }

        setLoading(true);
        setLoading(true);
        if (!nextPage) {
            setResults([]);
            setPagination(null);
            setSelectedPlaces({});
        }

        try {
            if (nextPage && pagination && pagination.hasNextPage) {
                pagination.nextPage();
                return;
            }
            // We need to use the Text Search API
            // Note: In a real production app, this should be done via a backend proxy to hide the API key
            // But for this local tool, we'll use the key directly.
            const apiKey = import.meta.env.VITE_GOOGLE_MAPS_API_KEY;

            // We'll use a simple fetch to the Google Places API
            // We need to use a proxy or JSONP if CORS is an issue, but let's try direct fetch first
            // If CORS blocks it, we might need to use the existing 'geocode' function or a new one.
            // For now, let's assume we can use the client-side library if loaded, or fetch.

            // Actually, since we have the Google Maps script loaded in index.html (presumably), 
            // Create a temporary div for the PlacesService
            const mapDiv = document.createElement('div');
            const map = new window.google.maps.Map(mapDiv, {
                center: { lat: 9.5, lng: 100.0 },
                zoom: 12
            });

            const service = new window.google.maps.places.PlacesService(map);

            // Define Koh Samui center and search within this area only
            const koSamuiCenter = { lat: 9.5, lng: 100.0 }; // Center of Koh Samui
            const searchRadius = 25000; // 25km radius to cover the whole island

            const request = {
                query: query + " Koh Samui", // Always append "Koh Samui" to search
                location: koSamuiCenter,
                radius: searchRadius,
                fields: ['name', 'formatted_address', 'geometry', 'photos', 'rating', 'user_ratings_total', 'types', 'place_id']
            };

            service.textSearch(request, (newResults, status, paginationObj) => {
                if (status === window.google.maps.places.PlacesServiceStatus.OK && newResults) {
                    setResults(prev => nextPage ? [...prev, ...newResults] : newResults);
                    setPagination(paginationObj);
                } else {
                    console.error("Places Search Status:", status);
                    toast({
                        title: "שגיאה בחיפוש",
                        description: `Status: ${status}`,
                        variant: "destructive"
                    });
                }
                setLoading(false);
            });

        } catch (error) {
            console.error("Search error:", error);
            toast({
                title: "שגיאה",
                description: "אירעה שגיאה בחיפוש",
                variant: "destructive"
            });
            setLoading(false);
        }
    };

    const mapCategory = (types) => {
        if (!types) return 'other';
        if (types.includes('restaurant') || types.includes('food')) return 'handyman'; // Temporary mapping, user should fix
        if (types.includes('lodging')) return 'other';
        // Add more mappings as needed
        return 'other';
    };

    const importPlace = async (place) => {
        try {
            setImporting(prev => ({ ...prev, [place.place_id]: true }));

            // Check if this place already exists
            const existing = await db.entities.ServiceProvider.filter({
                google_place_id: place.place_id
            });

            if (existing && existing.length > 0) {
                toast({
                    title: "העסק כבר קיים",
                    description: `${place.name} כבר יובא בעבר`,
                    variant: "default"
                });
                setImporting(prev => ({ ...prev, [place.place_id]: 'exists' }));
                return false;
            }

            // Get photo URL if available
            let imageUrls = [];
            if (place.photos && place.photos.length > 0) {
                imageUrls = [place.photos[0].getUrl({ maxWidth: 800 })];
            }

            const businessData = {
                business_name: place.name,
                category: mapCategory(place.types), // We might want to let user select this
                description: `Imported from Google Maps.${place.formatted_address} `,
                location: place.formatted_address,
                latitude: place.geometry.location.lat(),
                longitude: place.geometry.location.lng(),
                images: imageUrls,
                status: 'active',
                verified: true,
                average_rating: place.rating || 0,
                total_reviews: place.user_ratings_total || 0,
                google_place_id: place.place_id,
                phone: "0000000000", // Placeholder
                created_by: user?.email || "admin@kosamui.com" // Default admin email
            };

            await adminDb.entities.ServiceProvider.create(businessData);

            // Mark as imported in UI
            setImporting(prev => ({ ...prev, [place.place_id]: 'done' }));
            return true;

        } catch (error) {
            console.error("Import error:", error);

            // Check if it's a duplicate error (e.g., from a unique constraint violation on google_place_id)
            if (error.message && error.message.includes('duplicate key')) {
                toast({
                    title: "העסק כבר קיים",
                    description: `${place.name} כבר יובא בעבר`,
                    variant: "default"
                });
                setImporting(prev => ({ ...prev, [place.place_id]: 'exists' }));
            } else {
                toast({
                    title: "שגיאה בייבוא",
                    description: error.message,
                    variant: "destructive"
                });
                setImporting(prev => ({ ...prev, [place.place_id]: false }));
            }
            return false;
        }
    };

    const handleSingleImport = async (place) => {
        const success = await importPlace(place);
        if (success) {
            toast({
                title: "העסק יובא בהצלחה",
                description: `${place.name} נוסף למערכת`,
            });
        }
    };

    const toggleSelection = (placeId) => {
        setSelectedPlaces(prev => ({
            ...prev,
            [placeId]: !prev[placeId]
        }));
    };

    const toggleSelectAll = () => {
        const allSelected = results.every(r => selectedPlaces[r.place_id]);
        const newSelection = {};
        if (!allSelected) {
            results.forEach(r => {
                if (importing[r.place_id] !== 'done') {
                    newSelection[r.place_id] = true;
                }
            });
        }
        setSelectedPlaces(newSelection);
    };

    const importSelected = async () => {
        const placesToImport = results.filter(r => selectedPlaces[r.place_id]);
        if (placesToImport.length === 0) return;

        let successCount = 0;
        for (const place of placesToImport) {
            const success = await importPlace(place);
            if (success) successCount++;
        }

        toast({
            title: "ייבוא הושלם",
            description: `${successCount} עסקים יובאו בהצלחה`,
        });
        setSelectedPlaces({});
    };
    const selectedCount = Object.values(selectedPlaces).filter(Boolean).length;

    // Automated bulk import function
    const startAutomatedImport = async () => {
        setAutoImporting(true);
        setAutoStats({ imported: 0, skipped: 0, errors: 0 });
        setAutoProgress({ current: 0, total: searchCategories.length, category: '' });

        for (let i = 0; i < searchCategories.length; i++) {
            const category = searchCategories[i];
            setAutoProgress({ current: i + 1, total: searchCategories.length, category });

            try {
                // Search for this category
                await searchPlaces(category, false);

                // Wait a bit for results to load
                await new Promise(resolve => setTimeout(resolve, 2000));

                // Import all results from this search
                const currentResults = results;
                for (const place of currentResults) {
                    const success = await importPlace(place);
                    if (success) {
                        setAutoStats(prev => ({ ...prev, imported: prev.imported + 1 }));
                    } else {
                        // Check if it was skipped (already exists) or error
                        if (importing[place.place_id] === 'exists') {
                            setAutoStats(prev => ({ ...prev, skipped: prev.skipped + 1 }));
                        } else {
                            setAutoStats(prev => ({ ...prev, errors: prev.errors + 1 }));
                        }
                    }
                    // Small delay between imports to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                // Clear results for next category
                setResults([]);

            } catch (error) {
                console.error(`Error importing category ${category}:`, error);
                setAutoStats(prev => ({ ...prev, errors: prev.errors + 1 }));
            }

            // Delay between categories to avoid API rate limits
            await new Promise(resolve => setTimeout(resolve, 3000));
        }

        setAutoImporting(false);
        toast({
            title: "ייבוא אוטומטי הושלם!",
            description: `יובאו: ${autoStats.imported} | דולגו: ${autoStats.skipped} | שגיאות: ${autoStats.errors}`,
        });
    };

    return (
        <div className="min-h-screen bg-gray-50 p-8" dir="rtl">
            <div className="max-w-4xl mx-auto">
                <div className="flex justify-between items-center mb-8">
                    <h1 className="text-3xl font-bold">ייבוא עסקים מגוגל</h1>
                    <Card className="mb-8">
                        <CardContent className="p-6">
                            <div className="flex gap-4">
                                <Input
                                    placeholder="חפש עסקים (למשל: Italian Restaurants in Koh Samui)..."
                                    value={query}
                                    onChange={(e) => setQuery(e.target.value)}
                                    onKeyPress={(e) => e.key === 'Enter' && searchPlaces()}
                                    className="text-lg"
                                />
                                <Button onClick={searchPlaces} disabled={loading} className="w-32">
                                    {loading ? <Loader2 className="animate-spin" /> : <Search />}
                                    <span className="mr-2">חפש</span>
                                </Button>
                            </div>
                        </CardContent>
                    </Card>

                    {results.length > 0 && (
                        <div className="mb-4 flex items-center gap-2">
                            <input
                                type="checkbox"
                                className="w-5 h-5 rounded border-gray-300"
                                checked={results.length > 0 && results.every(r => selectedPlaces[r.place_id])}
                                onChange={toggleSelectAll}
                            />
                            <span className="text-sm font-medium">בחר הכל</span>
                        </div>
                    )}

                    <div className="grid gap-4">
                        {results.map((place) => (
                            <Card key={place.place_id} className={`overflow-hidden transition-colors ${selectedPlaces[place.place_id] ? 'ring-2 ring-blue-500 bg-blue-50' : ''}`}>
                                <div className="flex p-4 gap-4">
                                    <div className="flex items-center">
                                        <input
                                            type="checkbox"
                                            className="w-5 h-5 rounded border-gray-300"
                                            checked={!!selectedPlaces[place.place_id]}
                                            onChange={() => toggleSelection(place.place_id)}
                                            disabled={importing[place.place_id] === 'done'}
                                        />
                                    </div>
                                    <div className="w-32 h-32 bg-gray-200 rounded-lg flex-shrink-0 overflow-hidden relative">
                                        {place.photos && place.photos.length > 0 ? (
                                            <img
                                                src={place.photos[0].getUrl({ maxWidth: 200 })}
                                                alt={place.name}
                                                className="w-full h-full object-cover"
                                                onError={(e) => {
                                                    e.currentTarget.style.display = 'none';
                                                    const fallback = e.currentTarget.parentElement?.querySelector('.fallback-icon');
                                                    if (fallback) {
                                                        fallback.style.display = 'flex';
                                                    }
                                                }}
                                            />
                                        ) : null}
                                        <div className="fallback-icon w-full h-full flex items-center justify-center text-gray-400 absolute top-0 left-0" style={{ display: place.photos && place.photos.length > 0 ? 'none' : 'flex' }}>
                                            <ImageIcon />
                                        </div>
                                    </div>

                                    <div className="flex-1">
                                        <div className="flex justify-between items-start">
                                            <div>
                                                <h3 className="text-xl font-bold">{place.name}</h3>
                                                <p className="text-gray-600 flex items-center gap-1 mt-1">
                                                    <MapPin className="w-4 h-4" />
                                                    {place.formatted_address}
                                                </p>
                                                <div className="flex items-center gap-2 mt-2">
                                                    <Badge variant="secondary" className="flex items-center gap-1">
                                                        <Star className="w-3 h-3 fill-current" />
                                                        {place.rating} ({place.user_ratings_total})
                                                    </Badge>
                                                    {place.types && place.types.slice(0, 3).map(t => (
                                                        <Badge key={t} variant="outline">{t}</Badge>
                                                    ))}
                                                </div>
                                            </div>

                                            <Button
                                                onClick={() => handleSingleImport(place)}
                                                disabled={importing[place.place_id] === true || importing[place.place_id] === 'done'}
                                                variant={importing[place.place_id] === 'done' ? "outline" : "default"}
                                                className={importing[place.place_id] === 'done' ? "text-green-600 border-green-600" : ""}
                                            >
                                                {importing[place.place_id] === true ? (
                                                    <Loader2 className="animate-spin" />
                                                ) : importing[place.place_id] === 'done' ? (
                                                    <>
                                                        <Check className="w-4 h-4 mr-2" />
                                                        יובא
                                                    </>
                                                ) : (
                                                    <>
                                                        <Plus className="w-4 h-4 mr-2" />
                                                        ייבא
                                                    </>
                                                )}
                                            </Button>
                                        </div>
                                    </div>
                                </div>
                            </Card>
                        ))}

                        {results.length === 0 && !loading && (
                            <div className="text-center text-gray-500 py-12">
                                התחל לחפש כדי לראות תוצאות
                            </div>
                        )}

                        {pagination && pagination.hasNextPage && (
                            <div className="text-center py-4">
                                <Button
                                    onClick={() => searchPlaces(true)}
                                    disabled={loading}
                                    variant="outline"
                                    className="w-full max-w-xs"
                                >
                                    {loading ? <Loader2 className="animate-spin mr-2" /> : null}
                                    טען עוד תוצאות
                                </Button>
                            </div>
                        )}
                    </div>
                </div>
                {/* Hidden map to ensure script loads */}
                <div className="hidden">
                    <GoogleMap />
                </div>
            </div>
            );
}
